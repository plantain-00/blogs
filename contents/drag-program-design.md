# 拖拽交互的程序设计

这里说的拖拽交互是指拖拽元素触发的交互，例如：

+ 拖拽元素改变位置
+ 拖拽元素边缘改变元素大小
+ 拖拽滑块设置一个数值
+ 拖拽时钟指针设置时间

## 直接思路

这类问题的直接思路是，在待拖拽的元素上设置 drag 相关的事件处理程序，例如：

+ mousedown 事件：记录初始位置
+ mousemove 事件：根据当前位置和记录的初始位置，改变元素的位置或大小
+ mousedown 事件：根据最后的位置和记录的初始位置，返回需要的数据

这种思路某些复杂需求下会有缺点，包括：

+ 如果拖拽区域较小，且用户拖拽速度较快，会导致拖拽结束前就离开了拖拽区域，导致没有触发 mousedown 事件
+ 拖拽到别的不相关的元素上，触发不相关的元素的意外行为

## 透明蒙版

透明蒙版可以解决上面所说的问题，具体思路为：

+ 增加覆盖整个页面的透明蒙版，初始位置数据一旦设置，透明蒙版就出现，清空初始位置数据时透明蒙版就会隐藏
+ 拖拽元素的 mousedown 事件：记录初始位置
+ 透明蒙版的 mousemove 事件：根据当前位置和记录的初始位置，改变元素的位置或大小
+ 透明蒙版的 mouseup、mouseleave 事件：根据最后的位置和记录的初始位置，返回需要的数据，清空初始位置数据

## 如果拖拽过程有耗时操作

例如一个元素从初始尺寸拖拽成一个新的尺寸，元素内容需要复杂的计算才能得到新尺寸下的显示效果，而拖拽时会频繁触发 mousemove 可能导致性能问题。解决思路有：

+ 拖拽时只更新元素框，拖拽结束时才更新元素内容：交互效果不完美，但可以接受。
+ 通过 debounce 限制更新元素内容的频率，提高交互效果的同时，避免性能问题。

## 如果有回撤功能

拖拽时产生的大量数据记录到操作历史中，会导致回撤基本不可用，解决思路为：

+ 拖拽时返回的数据直接存储在组件本地 state 上，元素框根据这个 state 的数据显示
+ 拖拽时返回的数据 debounce 后存储在组件本地 state 上，元素内容根据这个 state 的数据做复杂计算后显示
+ 拖拽结束后返回的数据存储在编辑器操作历史 state 上，元素内容根据这个 state 的数据做复杂计算后显示，清空本地 state
+ 元素内容的计算中，如果本地 state 上有数据，说明在拖拽中，使用这个数据进行计算，否则拖拽已经结束，使用编辑器操作历史 state 上的数据进行计算

## 如果元素内容的计算耗时不可控

可能出现拖拽完成后的计算结束后，拖拽中的数据的计算结果才返回。

解决方案是，拖拽中的数据的计算后，如果已经拖拽结束，丢弃计算结果。
